/*
vim: syntax=groovy
-*- mode: groovy;-*-
 * -------------------------------------------------
 * Nextflow config file for CAW project
 * -------------------------------------------------
 * Configuration for running on a single UPPMAX node
 * such as milou or bianca
 * -------------------------------------------------
 */

env {
  NXF_WORK="/scratch"
}

params {
  singleCPUMem  = 8.GB
  totalMemory = 104.GB
}

process {
  cpus = 1
  errorStrategy = {task.exitStatus == 143 ? 'retry' : 'terminate'}
  maxErrors = '-1'
  maxForks = 2  // number of processess launched. If your process is using only a single CPU, and not that much memory, you can increase this value
  maxRetries = 3
  memory = {params.singleCPUMem}

  // These processes are defined in buildReferences.nf

  $BuildBWAindexes {
    memory = {params.totalMemory}
  }
  $BuildPicardIndex {
    memory = {params.totalMemory}
  }
  $BuildSAMToolsIndex {
    memory = {params.totalMemory}
  }
  $BuildVCFIndex {
    memory = {params.totalMemory}
  }

  // These processes are defined in main.nf

  $ConcatVCF {
    cpus = 16
    memory = {params.totalMemory}
  }
  $CreateRecalibrationTable {
    cpus = 16
    memory = {params.totalMemory}
  }
  $IndelRealigner {
    memory = {params.singleCPUMem * 2 * task.attempt}
  }
  $MapReads {
    cpus = 16
    memory = {params.totalMemory}
  }
  $MarkDuplicates {
    memory = {params.singleCPUMem * 2 * task.attempt}
  }
  $MergeBams {
    cpus = 16
    memory = {params.totalMemory}
  }
  $RealignerTargetCreator {
    cpus = 4
    memory = {params.singleCPUMem * 4 * task.attempt}
  }
  $RecalibrateBam {
    memory = {params.singleCPUMem * task.attempt}
  }
  $RunAlleleCount {
    memory = {params.singleCPUMem * 2 * task.attempt}
  }
  $RunAscat {
    memory = {params.singleCPUMem * 2 * task.attempt}
  }
  $RunBamQC {
    cpus = 16
    memory = {params.totalMemory}
  }
  $RunBcftoolsStats {
  }
  $RunConvertAlleleCounts {
    memory = {params.singleCPUMem * 2 * task.attempt}
  }
  $RunFastQC {
    errorStrategy = { task.exitStatus == 143 ? 'retry' : 'ignore' }
  }
  $RunFreeBayes {
    maxForks = 16
    memory = {params.singleCPUMem * task.attempt}
  }
  $RunHaplotypecaller {
    memory = {params.singleCPUMem * task.attempt * task.attempt } // this way the memory will increase quadratically as 8G, 32G, 72G
    maxForks = 16  // if you are running out of memory on a single node, due to task re-runs, decrease this value
  }
  $RunGenotypeGVCFs {
    memory = {params.singleCPUMem}
  }
  $RunManta {
    cpus = 16
    memory = {params.totalMemory}
  }
  $RunMultiQC {
    memory = {params.singleCPUMem}
    errorStrategy = { task.exitStatus == 143 ? 'retry' : 'ignore' }
  }
  $RunMutect1 {
    maxForks = 16
    memory = {params.singleCPUMem * task.attempt}
  }
  $RunMutect2 {
    maxForks = 16
    memory = {params.singleCPUMem * task.attempt}
  }
  $RunSamtoolsStats {
  }
  $RunSnpeff {
    memory = {params.totalMemory}  // TODO Does SnpEff really require that much?
    errorStrategy = { task.exitStatus == 143 ? 'retry' : 'ignore' }
  }
  $RunStrelka {
    cpus = 16
    memory = {params.totalMemory}
  }
  $RunVEP {
    memory = {params.totalMemory}  // TODO Does VEP really require that much?
    errorStrategy = { task.exitStatus == 143 ? 'retry' : 'ignore' }
  }
}
